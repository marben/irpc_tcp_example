package main

import (
	"irpc_tcp_example"
	"log"
	"net"
	"time"

	"github.com/marben/irpc"
)

func main() {
	serviceAddr := ":8080"

	log.Println("connecting to", serviceAddr)

	// standard net.Dial tcp connection
	tcpConn, err := net.Dial("tcp", serviceAddr)
	if err != nil {
		log.Fatalf("failed to connect: %v", err)
	}
	defer tcpConn.Close()

	// irpc.Endpoint is needed on both sides of connection.
	ep := irpc.NewEndpoint(tcpConn)

	// NewBackendIRpcClient is generated by irpc command from our Backend interface and implements our Backend interface
	backendClient, err := irpc_tcp_example.NewBackendIRpcClient(ep)
	if err != nil {
		log.Fatalf("failed to create client: %v", err)
	}

	// since backendClient implements Backend interface, we could pass it anywhere, where Backend interface is expected
	// this allows for simple local development in single binary and later trivial extension to network service

	// time to make network calls:

	// REVERSE STRING
	strIn1 := "Říčany"
	revStart := time.Now()
	resRev, err := backendClient.ReverseString(strIn1)
	if err != nil {
		log.Fatalf("ReverseString(): %v", err)
	}
	revLat := time.Since(revStart)
	log.Printf("ReverseString(%q) => %q [latency: %s]", strIn1, resRev, revLat)

	// REPEAT STRING
	strIn2 := "ネコ"
	repStart := time.Now()
	resRep, err := backendClient.RepeatString(strIn2, 3)
	if err != nil {
		log.Fatalf("RepeatString(): %v", err)
	}
	repLat := time.Since(repStart)
	log.Printf("RepeatString(%q, %d) => %q [latency: %s]", strIn2, 3, resRep, repLat)

	// TIME TO STRING
	resStart := time.Now()
	resTime, err := backendClient.TimeToString(resStart)
	if err != nil {
		log.Fatalf("TimeToString(): %v", err)
	}
	timeLat := time.Since(resStart)
	log.Printf("TimeToString(%q) => %q [latency: %s]", resStart, resTime, timeLat)
}
