package main

import (
	"github.com/marben/irpc/pkg/irpc"
	"irpc_tcp_example"
	"log"
	"net"
)

type MathImplementation struct {
	skew int // skew is just to add on more bit of complexity to otherwise nonsensical remote add function
}

func (rm MathImplementation) Add(x int, y int) (int, error) {
	res := x + y + rm.skew
	log.Printf("calculating Add: %d + %d + %d (skew) = %d", x, y, rm.skew, res)

	return res, nil
}

func main() {
	// define the Math implementation
	mathImpl := MathImplementation{skew: 8}

	// mathIrpcService is irpc.Service that forwards all remote calls to "mathImpl"
	// it is generated by the irpc command and resides in our math_irpc.go
	mathIrpcService := irpc_tcp_example.NewMathIRpcService(mathImpl)

	// irpc.Server can register any number of different services and service versions
	// we only have one
	irpcServer := irpc.NewServer(mathIrpcService)

	// open standard tcp listener
	tcpListener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatalf("error opening tcp listener: %v", err)
	}

	log.Printf("listening on port 8080")

	// Serve() creates irpc endpoint, registers our services and serves remote clients
	if err := irpcServer.Serve(tcpListener); err != nil {
		log.Println("irpcServer.Serve():", err)
	}
}
