# irpc over tcp example
Irpc is a library and a code generator that generates network code based on your go interface definition.

Irpc allows for bidirectional rpc calls over any io.ReadWriteCloser such as Tcp socket or Websocket etc

It allows for very seamless integration of rpc into your go project as both generated server and client code directly use and implement your interface definition. 

This repo is a trivial example use of irpc for remote function call Add(a,b int) which adds two ints.

Repository consist of 4 go files:

## `math.go`
definition of our api.

Return error is needed in case of network error. If not present, irpc would generate a panic call on network error
```go
type Math interface {
	Add(a, b int) (int, error)
}
```

## `cmd/server/main.go`
serves irpc calls on tcp port 8080

interesting bits:
```go
// open standard tcp listener
tcpListener, err := net.Listen("tcp", ":8080")

// MathImplementation is actual implementation of Add(a, b int) function
mathImpl := MathImplementation{skew: 8} // skew is just to add on more bit of complexity to otherwise nonsensical remote add function

// irpc service is a generated type and accepts remote calls and forwards them to corresponding functions on mathImpl
// it has to be hooked to irpc.Server
mathIrpcService := irpc_tcp_example.NewMathIRpcService(mathImpl)

// irpc.Server can register any number of different services and service versions
// we only have one
irpcServer := irpc.NewServer(mathIrpcService)

// Serve() creates irpc endpoint, register our services and serves remote calls on port 8080
err := irpcServer.Serve(tcpListener)
```
## `cmd/client/main.go` 
connects to localhost irpc server on port 8080 and makes irpc function call

```go
// standard net.Dial tcp connection
tcpConn, err := net.Dial("tcp", ":8080")

// irpc.Endpoint is needed on both sides of connection.
// irpc.NewEndpoint() can also register services, if client were to provide services to the server. we don't need that here
ep := irpc.NewEndpoint(tcpConn)

// NewRemoteMathIRpcClient is generated by irpc command from our Math interface
// it implements our Math interface
mathClient, err := irpc_tcp_example.NewMathIRpcClient(ep)

res, err := mathClient.Add(1, 2)
```

## `math_irpc.go`
generated irpc network code

can be regenerated by running `$ irpc math.go` (irpc command tool needs to be installed)

important generated bits:

#### creating a server-side service, that takes actual implementation and calls it:
```go
func NewMathIRpcService(impl Math) *MathIRpcService
```
#### creating client (which implements Math interface):
```go
func NewMathIRpcClient(endpoint *irpc.Endpoint) (*MathIRpcClient, error)
```