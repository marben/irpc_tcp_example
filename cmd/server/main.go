package main

import (
	"github.com/marben/irpc/pkg/irpc"
	"irpc_tcp_example"
	"log"
	"net"
)

type RemoteMathImplementation struct {
	skew int // we add skew to all our results, to make the unique!
}

func (rm RemoteMathImplementation) Add(x int, y int) (int, error) {
	log.Printf("Add: %d + %d + %d (skew)", x, y, rm.skew)
	return x + y + rm.skew, nil
}

func main() {
	// define the RemoteMath implementation
	mathImpl := RemoteMathImplementation{skew: 8}

	// mathService is irpc service that forwards all remote calls to "mathImpl"
	// it is generated by the irpc command and resides in our protocol_irpc.go
	mathService := irpc_tcp_example.NewRemoteMathIRpcService(mathImpl)

	// irpc server can register any number of different services and service versions
	// for now there is just one
	srvr := irpc.NewServer(mathService)

	// open standard tcp listener
	listener, err := net.Listen("tcp", ":8080")
	if err != nil {
		log.Fatalf("error opening tcp listener: %v", err)
	}

	log.Printf("listening on port 8080")

	// Serve creates irpc endpoint, register our services and serves remote calls
	if err := srvr.Serve(listener); err != nil {
		log.Println("srvr.Serve():", err)
	}
}
